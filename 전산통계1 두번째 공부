# 데이터 병합
height<-data.frame(id=c(1,2,3),h=c(180,175,155))
height
weight<-data.frame(id=c(1,2,4),
                   w=c(80,75,49))
weight
user<-merge(height,weight,by='id')#by ->뭘 기준으로 병합할건지,교집합으로만
user
?merge
(user2<-merge(height,weight,by="id"))

(user1<-merge(height,weight,by='id',all.x=TRUE))#x=height의자료를 다넣어줘라.
(user3<-merge(height,weight,by='id',all.y=TRUE))#y=weight의자료를 다넣어줘라.
user3
user4<-merge(height,weight,by='id',all=T)#x,y상관없이 다 넣어줘라잉~
user4
height<-data.frame(id1=c(1,2,3),h=c(180,175,155))
height
weight<-data.frame(id2=c(1,2,4),
                   w=c(80,75,49))
height
weight
###복습해볼것.
user1<-merge(height,weight,by.x='id1',by.y='id2',all.x=TRUE)#x=height의자료를 다넣어줘라.
user1
user3<-merge(height,weight,by.x='id1',by.y='id2',all.y=TRUE)#y=weight의자료를 다넣어줘라.
user3
user4<-merge(height,weight,by.x='id1',by.y='id2',all=T)
user4
###

#키보드 입력
num<-scan()
num
?scan

name<-scan(what=character()) #캐릭터형으로 저장하고싶다.
name
df<-data.frame()
df<-edit(df)
library(regbook)
# cat 함수 
x<-10
y<-20
print(x)
print(y)
cat("x*y=",x*y,sep="")
cat("x",x,";y=",y,"; x*y=",x*y,sep="")
# 로컬 파일 읽기
getwd()
setwd("/Users/seph/전산통계1/데이터 자료/part1")
setwd(readclipboard())
student<-read.table("student.txt")
names(student)<-c("번호","이름","키","몸무게")
student<-read.table("student1.txt",header=T,encoding="UTF-8")#다음시간.
# 웹 문서 읽기
install.packages("XML")
install.packages("httr")
library(XML)
library(httr)
ur<-"https://ssti.org/blog/useful-stats-capita-personal-income-state-2010-2015"
get_url<-GET(ur)
con<-rawToChar(get_url$content)
readHTMLTable(con)
library(stringr)
str_extract_all(con,"<table")
str_locate_all(con,"<table")
str_sub(con,38562,38662)
html_cont<-readHTMLTable(con)
html_cont<-as.data.frame(readHTMLTable(con))#데이타프레임
class(html_cont)
# 조건문
# if 문 only
score<-85
result<-"B"
if(score>80) {result<-"A"}
score
result
cat("당신의 학점은",result,"(",score,")입니다.",sep="")
# if ~ else if
score<-40
if (score>=90) {result<-"A"
} else if (score>=80) {result<-"B"
} else if (score>=70) {result<-"C"
} else {result<-"F"}




# if else문 
score<- c(100, 85, 70)
names(score)<-c("james","jane","thomas")
score
ifelse(score>=90,"A","B")
#switch 문
input<-"name"
switch(input,id="hong",pw="1234",age=40,name="James")

#which
no<-1:5
name<-c("james","jane","thomas","minsu","seph")
score<-c(70,85,75,90,100)
exam<-data.frame(학번=no,이름=name,성적=score)
exam$학번
exam[which(exam$학번==5),]

# 반복문(for 문)

d<-numeric()
for(i in 1:10){
  d[i]<-i*10
  cat(i,d[i],"\n")
}

# 홀수값 짝수값 출력
for (i in 1:10){
  if (i%%2==0) {print(i)}
}
for (i in 1:10){
  if (i%%2==0) {cat(i," ")}
}
for (i in 1:10){
  if (i%%2==0) {next
   }else cat(i," ")
} 

score<-c(50,80) 
name<-c("james","jane")
i<-1
for (s in score){
  cat(name[i]," 점수 ", s,"\n")
  i<-i+1
}
i<-0
while (i<10){
  i<-i+1
  print(i)
}




# 로컬 파일 읽기
getwd()
setwd("/Users/seph/전산통계1/데이터 자료/part1")
student<-read.table("student.txt")
student
class(student)#글의 구조가나오지만#자료의구조
mode(student)# mode는 그안에 내용이 안나오고 리스트란형태로나옴(기본) #자료안의모드
names(student) # 키값이 나옴
colnames(student)
names(student)<-c("번호","이름","키","몸무게")
student
student1<-read.table('student1.txt',header=T,fileEncoding = "CP949", encoding = "UTF-8")
student1<-read.table(file.choose(),header=T,fileEncoding = "CP949", encoding = "UTF-8")
student1
student2<-read.table('student2.txt',header=T,fileEncoding = "CP949", encoding = "UTF-8",sep=";")
student2

student3<-read.table('student3.txt',header=T,fileEncoding = "CP949", encoding = "UTF-8",
                     na.string=c('&','-')) #두문자를 na로 보겠다 하면c써서 해놓음됨
student3
student4<-read.table('student4.txt',header=T,fileEncoding = "CP949", encoding = "UTF-8",sep=","
                     , na.strings=c("+","$","-"))
student4<-read.csv('student4.txt',header=T,fileEncoding = "CP949", encoding = "UTF-8",sep=","
                     , na.strings=c("+","$","-"))
#csv 컴마 세퍼레이트 밸류 (컴마를 기준으로하기때문에 sep=',' 을 기준삼아 할필요없다)
student4
install.packages('data.table')
library(data.table)
stock<-read.csv('stock.csv')
stock
stock<-fread('stock.csv') #이게 read보다 읽는속도 빠르다
stock
install.packages('xlsx')
install.packages('rJava')

#java
Sys.setencv(JAVA_HOME=)

write.table(student,'student_new.txt',row.names=F,quote=F)
fwrite(stock,"stock.csv")
write.xlsx(studentex,"studentex_new.xslx",row.names=F) #옵션이 뭐가있는지 기억할것.



# R 내장함수
# 행,열 합계 및 평균 구하기
install.packages("RSADBE")
library(RSADBE)
data("Bug_Metrics_Software")
bug<-Bug_Metrics_Software
bug
class(bug)
mode(bug)
bug[,,1]
bug[,,2]
class(bug[,,1])
rowSums(bug[,,1]) # 행 별로 합
rowMeans(bug[,,1])# 행 별로 평균
apply((bug[,,1]),1,sum) # apply를 이용한 1=행,합
apply((bug[,,1]),1,mean)# apply를 이용한 1=행,평균
colSums(bug[,,1]) # 열 별로 합
colMeans(bug[,,1])# 열 별로 평균

# 난수 생성 및 확률 분포
# 정규분포
n<-1000
r<-rnorm(n,mean=0,sd=1)# rnorm(n,0,1)해도됨
r#1000개의 난수 만들귀? ㄱㅣ?
length(r)
hist(r,col="light blue",main="Histogram of random numbers",breaks=20) # main= 제목 ,col=색
# 균등 분포 uniform distribution
n<-1000
r2<-runif(n,min=0,max=1) # runif(n,0,1) 해도됨.
r2
hist(r2,col='pink')
# 이항 분포 binomial distribution
?rbinom
set.seed(123) # seed설정하고 동시에 같이시행하면 순서 고정됨.
n<-20
rbinom(n,1,prob=0.5)
rbinom(n,2,0.5)
rbinom(n,10,0.5)

# 사용자 정의 함수
# 매개변수가 없는 함수
f1<-function(){
  cat("매개 변수가 없는 함수!!")
}# 함수를 정의하고 호출하는 방식
f1()

# 매개변수가 있는 함수
f2<-function(x,y){
  cat("x =",x,"y =",y,sep="")
}
f2(10,5)

# 리턴값이 있는 함수
f3<-function(x,y){
  prod<-x*y
  return(prod)
}
prod<-f3(10,20)
prod

# 분산과 표준편차
x<-c(7,5,12,9,15,6)
var(x)
sd(x)
sqrt(var(x))

var_sd<-function(x){
  var<-sum((x-mean(x))^2)/(length(x)-1)
  sd<-sqrt(var)
  cat("var = ",var,"sd = ",sd,sep="")
  res<-c(var,sd)
  return(res)
}
result<-var_sd(x)
result[2]

# 구구단 출력 함수
gugu<-function(i){
  for(x in i){
    cat("*******",x,"단출력입니다","\n")
    for(y in 1:9){
      cat(x," * ",y,"=",x*y,"\n",sep="")
    }
    
  }
}
gugu(3:5)

# 동전 앞/뒤 난수 확률 분포 함수
coin<-function(n){#n은 시행횟수
  r<-runif(n,0,1)
  res<-numeric() # 결과값을 넣을 무작위 아무 누메릭 벡터로만든것.
  for(i in 1:n){
    if(r[i]<=0.5) {res[i] <-0
    }else res[i]<-1
  }
  return(res)
}

coin(14)

coin<-function(n){
  r<-runif(n,0,1)
  res<-ifelse(r<=0.5,0,1)
  return(res)
}
coin(10)

#몬테카를로 시뮬레이션
montaCoin<-function(n){
  cnt<-0
  for(i in 1:n){
    cnt<-cnt+coin(1)
  }
  res<-cnt/n
  return(res)
}
montaCoin(10)
montaCoin(100)
montaCoin(1000)
montaCoin(100000)
cumprod(1:3)

chart_data<-c(305,450,320,460,330,480,380,520)
names(chart_data)<-c("2014-1","2015-1","2014-2","2015-2","2014-3","2015-3","2014-4","2015-4")


# bar plot 그리기 
barplot(chart_data,
        xlim=c(0,600),
        space=1.5,#간격.
        horiz=T,# horiz f=> 수직 horiz t => 수평 ,x,y,신경 써주기 .
        col=rainbow(8),
        xlab="매출액",
        ylab="연도별 분기현황",
        main="2014년도 vs 2015년도 분기별 매출현황 비교",
        cex.names=0.6) #cex.axis
par(family="AppleGothic")
barplot(chart_data)


#개별로 vad데쓰에 대해 나눠보기
data(VADeaths)
VADeaths
barplot(VADeaths,beside=T, #beside=F는 누적이고 T는겹쳐있던거 따로 떼기.
        col=rainbow(5),
        main="Death Rates in virginia")
legend(2,70,c('50-54',"55-59","60-64","65-69","70-74"),fill=rainbow(5),cex=0.6)
#dot 차트
chart_data
dotchart(chart_data,col=c("blue","red"),lcolor="black",pch=16:17,
         lables=names(chart_data),xlab="매출액",main="분기별 판매현황점 차트시각화",cex=1.2)
#col=("a",b")은 점의 색, lcolor구분선 검정색,pch는 각각의 모양,labels 점레이블 표시
#pie 차트
pie(chart_data,col=rainbow(8),cex=0.6,border="green",
    main="분기별 매출")
install.packages("plotrix")
library("plotrix")
pie3D(chart_data,col=rainbow(8),cex=0.8,explode=0.2,
      main="분기별 매출")


#histogram
data(iris)
iris
head(iris)
dim(iris)
summary(iris$Sepal.Length)

iris$Sepal.Length
hist(iris$Sepal.Length,xlab="Sepal length",col="pink",xlim=c(4,8),breaks=20
     ,freq=F)
lines(density(iris$Sepal.Length),col="red")
d<-density(iris$Sepal.Length)
x<-seq(4,8,0.1)
y<-dnorm(x,mean=(iris$Sepal.Length),sd=sd(iris$Sepal.Length))
curve(dnorm(x,mean=mean(iris$Sepal.Length),sd=sd(iris$Sepal.Length)))
length(y)
lines(x,y,col="red")
dens_width=density(iris$Sepal.Width)
names(dens_width)
range(dens_width$x)
?hist
#boxplot
boxplot(VADeaths,range=1,col="light blue") # range=0:최소값과 최대값을 점선으로 연결하는역활
boxplot(VADeaths,range=0,col="light blue",notch=F)
abline(h=37,lty=3,col="red")
cm<-colMeans(VADeaths)
points(1:4,cm,col="red",pch=16)
#Scatter plot (산점도)
set.seed(10)
price<-runif(10,min=1,max=100)
?runif
price
plot(price,col="blue",pch=16)
par(new=T)
plot(1:100,type='l',axes=F,ann=F,col='red') #이걸하기위해par(new=T)안하면 밑에 선만생김
text(70,80,"대각선 추가",col='blue')
par(family='AppleGothic')
#Draw scatter plot for overlapped points
install.packages("HistData")
library('HistData')
data(Galton)
head(Galton)
table(Galton$child)
galtonData<-as.data.frame(table(Galton$child,Galton$parent))
names(galtonData)<-c("child","parent","freq")
galtonData
plot(galtonData$parent,galtonData$child)
summary(galtonData)
mode(galtonData$parent)
plot(as.numeric(galtonData$parent),
     as.numeric(galtonData$child),col='blue',bg='green',pch=21)#겉은 블루 속은 그린채움
plot(as.numeric(galtonData$parent),
     as.numeric(galtonData$child),col='blue',bg='green',pch=21,cex=0.2*galtonData$freq,
     xlab="parent",ylab="child")
# cex freq를 사용함으로써 겹치는거에대해 겹칠수록 두꺼워짐(커짐) .

x<-rnorm(1000)
y<-rnorm(1000)
xy<-matrix(c(x,y),length(x),2)
colnames(xy)<-c("x","y")
xy
head(xy)
plot(xy,col="blue",pch=16,cex=2) # 겹치는걸 구분을 할수없음 

densCols(xy) #천개에대한 색깔을 리턴해줌 
plot(xy,col=densCols(xy),pch=16,cex=2) #사용해보면 겹칠수록 진해지게 변경됨
